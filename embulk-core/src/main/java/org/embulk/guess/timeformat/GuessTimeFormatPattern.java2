package org.embulk.guess.timeformat;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

static class GuessTimeFormatPattern extends TimeFormatPattern {

        static final String YMD_NODELIM = String.format(
                "^(?<year>%s)(?<month>%s)(?<day>%s)(?<rest>.*?)$", YEAR, MONTH_NODELIM, DAY_NODELIM);

        // MM/dd/yyyy
        static final String MDY = String.format(
                "(?<month>%s)(?<date_delim>%s)(?<day>%s)\\k<date_delim>(?<year>%s)", MONTH, DATE_DELIMS, DAY, YEAR);
        static final String MDY_NODELIM = String.format(
                "(?<month>%s)(?<day>%s)(?<year>%s)", MONTH_NODELIM, DAY_NODELIM, YEAR);
        static final Pattern MDY_REST = Pattern.compile(String.format("^%s(?<rest>.*?)$", MDY));
        static final Pattern MDY_NODELIM_REST = Pattern.compile(String.format("^%s(?<rest>.*?)$", MDY_NODELIM));

        // dd.MM.yyyy
        static final String DMY = String.format(
                "(?<day>%s)(?<date_delim>%s)(?<month>%s)\\k<date_delim>(?<year>%s)", DAY, DATE_DELIMS, MONTH, YEAR);
        static final String DMY_NODELIM = String.format(
                "(?<day>%s)(?<month>%s)(?<year>%s)", DAY_NODELIM, MONTH_NODELIM, YEAR);
        static final Pattern DMY_REST = Pattern.compile(String.format("^(?<rest>.*?)$", DMY));
        static final Pattern DMY_NODELIM_REST = Pattern.compile(String.format("^(?<rest>.*?)$", DMY_NODELIM));

    @Override
    public Match match(final String text) {
        final ArrayList<String> delimiters = new ArrayList<>();
        final ArrayList<Part> parts = new ArrayList<>();
        final ArrayList<Option> partOptions = new ArrayList<>();


            final String dateDelim;
            final String rest;
            if (ymdMatcher != null) {
                dateDelim = group(ymdMatcher, "date_delim", "");

                parts.add(Part.YEAR);
                partOptions.add(null);  // To be compacted.

                delimiters.add(dateDelim);
                parts.add(Part.MONTH);
                partOptions.add(partHeadingOption(ymdMatcher.group("month")));

                delimiters.add(dateDelim);
                parts.add(Part.DAY);
                partOptions.add(partHeadingOption(ymdMatcher.group("day")));

                rest = ymdMatcher.group("rest");
            } else if (mdyMatcher != null) {
                dateDelim = group(mdyMatcher, "date_delim", "");

                parts.add(Part.MONTH);
                partOptions.add(partHeadingOption(ymdMatcher.group("month")));

                delimiters.add(dateDelim);
                parts.add(Part.DAY);
                partOptions.add(partHeadingOption(ymdMatcher.group("day")));

                delimiters.add(dateDelim);
                parts.add(Part.YEAR);
                partOptions.add(null);  // To be compacted.

                rest = mdyMatcher.group("rest");
            } else if (dmyMatcher != null) {
                dateDelim = group(dmyMatcher, "date_delim", "");

                parts.add(Part.DAY);
                partOptions.add(partHeadingOption(ymdMatcher.group("day")));

                delimiters.add(dateDelim);
                parts.add(Part.MONTH);
                partOptions.add(partHeadingOption(ymdMatcher.group("month")));

                delimiters.add(dateDelim);
                parts.add(Part.YEAR);
                partOptions.add(null);  // To be compacted.

                rest = dmyMatcher.group("rest");
            } else {
                dateDelim = "";
                return null;
            }

            Pattern.compile(String.format("^(?<date_time_delim>%s)%s(?<rest>.*?)?$", DATE_TIME_DELIMS, TIME));
            Pattern.compile(String.format("^(?<date_time_delim>%s)%s(?<rest>.*?)?$", DATE_TIME_DELIMS, TIME_NODELIM));
            Pattern.compile(String.format("^%s(?<rest>.*?)?$", TIME_NODELIM));
            /*
        if tm = (
              /^(?<date_time_delim>#{date_time_delims})#{TIME}(?<rest>.*?)?$/.match(rest) or
              /^(?<date_time_delim>#{date_time_delims})#{TIME_NODELIM}(?<rest>.*?)?$/.match(rest) or
              (date_delim == "" && /^#{TIME_NODELIM}(?<rest>.*?)?$/.match(rest))
            )
          date_time_delim = tm["date_time_delim"] rescue ""
          time_delim = tm["time_delim"] rescue ""

          delimiters << date_time_delim
          parts << :hour
          part_options << part_heading_option(tm["hour"])

          if tm["minute"]
            delimiters << time_delim
            parts << :minute
            part_options << part_heading_option(tm["minute"])

            if tm["second"]
              delimiters << time_delim
              parts << :second
              part_options << part_heading_option(tm["second"])

              if tm["frac"]
                delimiters << tm["frac_delim"]
                parts << :frac

                //// Here, reduce the integer "size" into Option
                part_options << tm["frac"].size
              end
            end
          end

          rest = tm["rest"]
        end

        if zm = /^#{ZONE}$/.match(rest)
          delimiters << (zm["zone_space"] || '')
          parts << :zone
          if zm["zone_off"]
            if zm["zone_off"].include?(':')
              part_options << :extended
            else
              part_options << :simple
            end
          else
            part_options << :abb
          end

          return GuessMatch.new(delimiters, parts, part_options)

        elsif rest =~ /^\s*$/
          return GuessMatch.new(delimiters, parts, part_options)

        else
          return nil
        end
*/
            return null;
    }

    private static Option partHeadingOption(final String text) {
        if (text.charAt(0) == '0') {
            return Option.ZERO;
        } else if (text.charAt(0) == ' ') {
            return Option.BLANK;
        } else if (text.length() == 1) {
            return Option.NONE;
        } else {
            return null;
        }
    }

    private static String group(final Matcher matcher, final String name, final String defaultValue) {
        try {
            return matcher.group(name);
        } catch (final IllegalArgumentException ex) {
            return defaultValue;
        }
    }

    enum Order {
        YMD,
        MDY,
        DMY,
        ;
    }

    private static class DateMatcher {
        DateMatcher(final Pattern pattern, final boolean useDateDelim, final Order order) {
            this.pattern = pattern;
            this.useDateDelim = useDateDelim;
            this.order = order;
        }

        DateMatched match(final String text) {

        }

        private final Pattern pattern;
        private final boolean useDateDelim;
        private final Order order;
    }

    private static DateMatcher[] DATE_MATCHERS = {
        new DateMatcher(YMD_DELIM, true, Order.YMD),
        new DateMatcher(YMD_NODELIM, false, Order.YMD),
        new DateMatcher(MDY_DELIM, true, Order.MDY),
        new DateMatcher(MDY_NODELIM, false, Order.MDY),
        new DateMatcher(DMY_DELIM, true, Order.DMY),
        new DateMatcher(DMY_NODELIM, false, Order.DMY)
    };

    static class DateMatched {
        private MatchWithDate() {
        }

        public String getYear() {
            return this.year;
        }

        public String getDateDelim() {
            return this.dateDelim;
        }

        public String getMonth() {
            return this.month;
        }

        public String getDay() {
            return this.day;
        }

        public String getRest() {
            return this.rest;
        }
    }

                "^(?<year>%s)(?<date_delim>%s)(?<month>%s)\\k<date_delim>(?<day>%s)(?<rest>.*?)$",
                YEAR, DATE_DELIMS, MONTH, DAY);

        static final String YMD_NODELIM = String.format(
                "^(?<year>%s)(?<month>%s)(?<day>%s)(?<rest>.*?)$", YEAR, MONTH_NODELIM, DAY_NODELIM);

        // MM/dd/yyyy
        static final String MDY = String.format(
                "(?<month>%s)(?<date_delim>%s)(?<day>%s)\\k<date_delim>(?<year>%s)", MONTH, DATE_DELIMS, DAY, YEAR);
        static final String MDY_NODELIM = String.format(
                "(?<month>%s)(?<day>%s)(?<year>%s)", MONTH_NODELIM, DAY_NODELIM, YEAR);
        static final Pattern MDY_REST = Pattern.compile(String.format("^%s(?<rest>.*?)$", MDY));
        static final Pattern MDY_NODELIM_REST = Pattern.compile(String.format("^%s(?<rest>.*?)$", MDY_NODELIM));

        // dd.MM.yyyy
        static final String DMY = String.format(
                "(?<day>%s)(?<date_delim>%s)(?<month>%s)\\k<date_delim>(?<year>%s)", DAY, DATE_DELIMS, MONTH, YEAR);
        static final String DMY_NODELIM = String.format(
                "(?<day>%s)(?<month>%s)(?<year>%s)", DAY_NODELIM, MONTH_NODELIM, YEAR);
        static final Pattern DMY_REST = Pattern.compile(String.format("^(?<rest>.*?)$", DMY));
        static final Pattern DMY_NODELIM_REST = Pattern.compile(String.format("^(?<rest>.*?)$", DMY_NODELIM));


        final Matcher ymdDelimMatcher = ;
        final Matcher ymdNoDelimMatcher = YMD_NODELIM_REST.matcher(text);
        final Matcher ymdMatcher;
        if (ymdDelimMatcher.matches()) {
            ymdMatcher = ymdDelimMatcher;
        } else if (ymdNoDelimMatcher.matches()) {
            ymdMatcher = ymdNoDelimMatcher;
        } else {
            ymdMatcher = null;
        }

        final Matcher mdyDelimMatcher = MDY_REST.matcher(text);
        final Matcher mdyNoDelimMatcher = MDY_NODELIM_REST.matcher(text);
        final Matcher mdyMatcher;
        if (ymdMatcher != null) {
            mdyMatcher = null;
        } else if (mdyDelimMatcher.matches()) {
            mdyMatcher = mdyDelimMatcher;
        } else if (mdyNoDelimMatcher.matches()) {
            mdyMatcher = mdyNoDelimMatcher;
        } else {
            mdyMatcher = null;
        }

        final Matcher dmyDelimMatcher = DMY_REST.matcher(text);
        final Matcher dmyNoDelimMatcher = DMY_NODELIM_REST.matcher(text);
        final Matcher dmyMatcher;
        if (ymdMatcher != null && mdyMatcher != null) {
            dmyMatcher = null;
        } else if (dmyDelimMatcher.matches()) {
            dmyMatcher = dmyDelimMatcher;
        } else if (dmyNoDelimMatcher.matches()) {
            dmyMatcher = dmyNoDelimMatcher;
        } else {
            dmyMatcher = null;
        }

    }

    static final String YEAR = "[1-4][0-9]{3}";
    static final String MONTH = "10|11|12|[0 ]?[0-9]";
    static final String MONTH_NODELIM = "10|11|12|[0][0-9]";
    static final String DAY = "31|30|[1-2][0-9]|[0 ]?[1-9]";
    static final String DAY_NODELIM = "31|30|[1-2][0-9]|[0][1-9]";
    static final String HOUR = "20|21|22|23|24|1[0-9]|[0 ]?[0-9]";
    static final String HOUR_NODELIM = "20|21|22|23|24|1[0-9]|[0][0-9]";
    static final String MINUTE = "60|[1-5][0-9]|[0 ]?[0-9]";
    static final String SECOND = MINUTE;
    static final String MINUTE_NODELIM = "60|[1-5][0-9]|[0][0-9]";
    static final String SECOND_NODELIM = MINUTE_NODELIM;

    static final String MONTH_NAME_SHORT = "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";
    static final String MONTH_NAME_FULL =
            "January|February|March|April|May|June|July|August|September|October|November|December";

    static final String WEEKDAY_NAME_SHORT = "Sun|Mon|Tue|Wed|Thu|Fri|Sat";
    static final String WEEKDAY_NAME_FULL = "Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday";

    static final String ZONE_OFF = "(?:Z|[\\-\\+]\\d\\d(?::?\\d\\d)?)";
    static final String ZONE_ABB = "[A-Z]{1,3}";

    static final String DATE_DELIMS = "[\\/\\-\\.]";


    static final String FRAC = "[0-9]{1,9}";
    static final String TIME_DELIMS = "[\\:\\-]";
    static final String FRAC_DELIMS = "[\\.\\,]";

    static final String TIME = String.format(
                "(?<hour>%s)(?:(?<time_delim>%s)(?<minute>%s)" +
                "(?:\\k<time_delim>(?<second>%s)(?:(?<frac_delim>%s)(?<frac>%s))?)?)?",
                HOUR, TIME_DELIMS, MINUTE, SECOND, FRAC_DELIMS, FRAC);
    static final String TIME_NODELIM = String.format(
                "(?<hour>%s)(?:(?<minute>%s)((?<second>%s)(?:(?<frac_delim>%s)(?<frac>%s))?)?)?",
                HOUR_NODELIM, MINUTE_NODELIM, SECOND_NODELIM, FRAC_DELIMS, FRAC);

    static final String ZONE = String.format(
                "(?<zone_space> )?(?<zone>(?<zone_off>%s)|(?<zone_abb>%s))", ZONE_OFF, ZONE_ABB);

    static final String DATE_TIME_DELIMS = "(:? |_|T|\\. ?)";

    static final Pattern REST_TIME = Pattern.compile(String.format(
                "^(?<date_time_delim>%s)%s(?<rest>.*?)?$", DATE_TIME_DELIMS, TIME));
    static final Pattern REST_TIME_NODELIM = Pattern.compile(String.format(
                "^(?<date_time_delim>%s)%s(?<rest>.*?)?$", DATE_TIME_DELIMS, TIME_NODELIM));
    static final Pattern REST_TIME_NODELIM_DATE_NODELIM = Pattern.compile(String.format(
                "^%s(?<rest>.*?)?$", TIME_NODELIM));

    // yyyy-MM-dd
    static final Pattern YMD_DELIM = Pattern.compile(String.format(
            "^(?<year>%s)(?<date_delim>%s)(?<month>%s)\\k<date_delim>(?<day>%s)(?<rest>.*?)$",
            YEAR, DATE_DELIMS, MONTH, DAY));
}
